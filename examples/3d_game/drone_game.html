var THREE = window.THREE;

function init() {
    // Scene
    var scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);

    // Camera
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Ambient and Directional Lighting
    var ambientLight = new THREE.AmbientLight(0x444444);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(-10, 10, -10);
    scene.add(directionalLight);

    // Drone Model
    var droneGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    var droneMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
    var drone = new THREE.Mesh(droneGeometry, droneMaterial);
    drone.position.y = 1;
    scene.add(drone);

    // Landscape
    var landscape = new PerlinNoise(10, 10, 10, 10);
    for (var x = -100; x <= 100; x += 2) {
        for (var z = -100; z <= 100; z += 2) {
            var height = landscape.get(x / 10, z / 10);
            var geometry = new THREE.PlaneGeometry(1, 1);
            var material = new THREE.MeshLambertMaterial({ color: 0x222222 });
            var plane = new THREE.Mesh(geometry, material);

            if (height < 2) {
                plane.material.opacity = height / 2;
            }

            plane.position.x = x;
            plane.position.z = z;

            scene.add(plane);
        }
    }

    // Obstacles
    for (var i = 0; i < 100; i++) {
        var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshLambertMaterial({ color: 0x777777 });
        var obstacle = new THREE.Mesh(geometry, material);

        if (Math.random() > 0.9) {
            obstacle.position.x = Math.random() * 2 - 1;
            obstacle.position.z = Math.random() * 2 - 1;

            scene.add(obstacle);
        }
    }

    // Checkpoints
    var checkpoints = [];
    for (var i = 0; i < 10; i++) {
        var x = Math.random() * 200 - 100;
        var z = Math.random() * 200 - 100;

        geometry = new THREE.PlaneGeometry(1, 1);
        material = new THREE.MeshLambertMaterial({ color: 0x00000ff });
        plane = new THREE.Mesh(geometry, material);

        plane.position.x = x;
        plane.position.z = z;

        scene.add(plane);

        checkpoints.push(new Checkpoint(x, z));
    }

    // Drrones
    var drones = [];
    for (var i = 0; i < 10; i++) {
        var geometry = new THREE.BoxGeometry(1, 1, 1);
        var material = new THREE.MeshLambertMaterial({ color: 0x0000ff });
        var drone = new THREE.Mesh(geometry, material);

        if (Math.random() > 0.9) {
            drone.position.x = Math.random() * 2 - 1;
            drone.position.z = Math.random() * 2 - 1;

            drones.push(new Drone(drone));
        }

        scene.add(drone);
    }

    // A* Pathfinding
    for (var i = 0; i < checkpoints.length; i++) {
        var checkpoint = checkpoints[i];
        var drone = drones[Math.floor(Math.random() * drones.length)];

        var start = drone.position.clone();
        var end = checkpoint.position;

        var path = aStar(start, end, scene, obstacles);

        for (var j = 0; j < path.length - 1; j++) {
            var point = path[j];
            if (point.x > -100 && point.x < 100 && point.z > -100 && point.z < 100) {
                geometry = new THREE.PlaneGeometry(0.1, 0.1);
                material = new THREE.MeshLambertMaterial({ color: 0x666666 });
                var plane = new THREE.Mesh(geometry, material);

                plane.position.x = point.x;
                plane.position.z = point.z;

                scene.add(plane);
            }
        }
    }

    // UI
    var uiContainer = document.getElementById("ui");
    if (!uiContainer) {
        uiContainer = document.createElement("div");
        uiContainer.id = "ui";
        document.body.appendChild(uiContainer);

        var timerElement = document.createElement("div");
        timerElement.style.position = "absolute";
        timerElement.style.top = "0px";
        timerElement.style.left = "0px";
        timerElement.id = "timer";
        uiContainer.appendChild(timerElement);

        var speedElement = document.createElement("div");
        speedElement.style.position = "absolute";
        speedElement.style.top = "20px";
        speedElement.style.left = "50%";
        speedElement.id = "speed";
        uiContainer.appendChild(speedElement);

        var standingsElement = document.createElement("table");
        standingsElement.id = "standings";

        uiContainer.appendChild(standingsElement);

    }

    var timerElement = document.getElementById("timer");
    var speedElement = document.getElementById("speed");

    var stopwatch = new Stopwatch();
    var droneSpeed = 0;

    function update() {
        stopwatch.start();

        drone.position.x += droneSpeed;
        drone.position.z += droneSpeed;

        if (drone.position.x > 100) {
            drone.position.x = -100;
        }

        if (drone.position.x < -100) {
            drone.position.x = 100;
        }

        if (drone.position.z > 100) {
            drone.position.z = -100;
        }

        if (drone.position.z < -100) {
            drone.position.z = 100;
        }

        droneMaterial.nearestFace = getNearestFace(drone.position);

        updateStandings();

        uiContainer.style.backgroundPosition = `-${stopwatch.elapsed / 10}px`;

        requestAnimationFrame(update);
    }

    function updateStandings() {
        var standingsTable = document.getElementById("standings");

        while (standingsTable.rows.length > 0) {
            standingsTable.deleteRow(0);
        }

        for (var i = 0; i < checkpoints.length; i++) {
            var checkpoint = checkpoints[i];
            var drone = drones[Math.floor(Math.random() * drones.length)];

            if (drone.position.clone().distanceTo(checkpoint.position) <= 10) {
                var row = standingsTable.insertRow(i);

                row.innerHTML = `Time: ${drone.start.elapsed}ms`;
            }
        }

        speedElement.textContent = `${droneSpeed} m/s`;

        timerElement.textContent = `${stopwatch.elapsed / 1000}s`;
    }

    function getNearestFace(position) {
        var faces = [];
        for (var i = 0; i < droneMaterial.geometry faces.length; i++) {
            var face = droneMaterial.geometry.faces[i];
            if (face.a.x <= position.x && position.x <= face.b.x &&
                face.a.y <= position.y && position.y <= face.b.y &&
                face.a.z <= position.z && position.z <= face.b.z) {

                faces.push(face);
            }
        }

        return faces.length > 0 ? faces[0] : null;
    }

    update();

    document.addEventListener("keydown", function(event) {
        if (event.key == "ArrowUp") {
            droneSpeed += 0.01;
        } else if (event.key == "ArrowDown") {
            droneSpeed -= 0.01;
        } else if (event.key == "ArrowLeft") {
            drone.position.x -= 1;
        } else if (event.key == "ArrowRight") {
            drone.position.x += 1;
        }
    });

    document.addEventListener("keyup", function(event) {
        if (event.key == "ArrowUp" || event.key == "ArrowDown") {
            var min = Math.min(Math.abs(droneSpeed), Math.max(-droneSpeed, -0.01));
            droneSpeed = Math.max(min, -0.01);
        }
    });

    function aStar(start, end, scene, obstacles) {
        var openSet = [start];
        var cameFrom = {};
        var gScore = { [start]: 0 };
        var fScore = { [start]: distance(start, end) };

        while (openSet.length > 0) {
            var current = openSet.reduce((min, max) => distance(max, openSet[0]) < distance(min, openSet[0]) ? max : min);

            if (current == end) {
                var path = [current];
                while (cameFrom[current] != undefined) {
                    path.push(cameFrom[current]);
                    current = cameFrom[current];
                }
                return path.reverse();
            }

            openSet.splice(openSet.indexOf(current), 1);
            for (var neighbor in scene.obstacles) {
                var point = { x: scene.obstacles[neighbor].x, y: scene.obstacles[neighbor].y };
                if (point.x > current.x &&
                    point.y > current.y &&
                    point.x < end.x &&
                    point.y < end.y) {

                    var tentativeGScore = gScore[current] + distance(current, neighbor);
                    if (!gScore[neighbor] || tentativeGScore < gScore[neighbor]) {
                        cameFrom[neighbor] = current;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = tentativeGScore + distance(neighbor, end);

                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }

                }
            }
        }

        return [];
    }

    function distance(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2 +
            (a.z - b.z) ** 2);
    }

}

class Stopwatch {
    constructor() {
        this.start = Date.now();
        this.elapsed = 0;
    }

    start() {
        if (!this.running) {
            this.running = true;
            this.interval = setInterval(() => {
                this.elapsed = Date.now() - this.start;
            }, 10);
        }
    }

    pause() {
        clearInterval(this.interval);
        this.running = false;
    }

    reset() {
        this.start();
        this.elapsed = 0;
    }

}

var obstacles = [
    {x:20, y:60},
    {x:30, y:40}
];